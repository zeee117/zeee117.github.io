<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数据结构笔记</title>
      <link href="/2022/09/13/DataStructure/"/>
      <url>/2022/09/13/DataStructure/</url>
      
        <content type="html"><![CDATA[<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><h2 id="三类复杂度"><a href="#三类复杂度" class="headerlink" title="三类复杂度"></a>三类复杂度</h2><h3 id="1-Big-Theta-Θ"><a href="#1-Big-Theta-Θ" class="headerlink" title="1. Big Theta(Θ)"></a>1. Big Theta(Θ)</h3><ol><li><p>R(N): runtime</p><p>代表准确的运行时间，但我们所关心的不是精准的运行时间，而是运行时间的形态(如线性，二次)，即Θ(f(N))</p></li><li><p>达到展现R(N)形态的方法</p><ol><li><p>计算</p><ol><li>在程序中找到适合的语句(cost model)作为复杂度参考,计算运行的次数</li><li>找到适合的Θ(<em>f</em>(<em>N</em>))，通常我们只考虑最坏的情况(但不总是如此</li></ol></li><li><p>图形</p><blockquote><p>如Θ(N^2^)的图形就是覆盖一个二维平面</p></blockquote></li></ol></li></ol><img src="/2022/09/13/DataStructure/image-20220909085417518.png" alt="image-20220909085417518 " style="zoom:50%;"><ol start="3"><li>两个重要sum<ol><li>1+2+3+…+N∈Θ(N^2^)</li><li>1+2+4+8+…+N∈Θ(N)</li></ol></li></ol><h3 id="2-Big-O-O"><a href="#2-Big-O-O" class="headerlink" title="2. Big O(O)"></a>2. Big O(O)</h3><blockquote><p>表示等于或大于真实的时间复杂度</p></blockquote><p><strong>作用</strong></p><ul><li>对于一些根据输入不同所用时间不同的算法，无法准确判断时间复杂度，使用O可以解决不确定性</li><li>对有一些无法确定复杂度的算法有效，可以确定其上限</li><li>相比于Θ证明更容易</li></ul><h3 id="3-Big-Omega-Ω"><a href="#3-Big-Omega-Ω" class="headerlink" title="3. Big Omega(Ω)"></a>3. Big Omega(Ω)</h3><blockquote><p>表示小于或等于真实的时间复杂度</p></blockquote><p><strong>作用</strong></p><ul><li>有时Θ的计算很困难，而O和Ω的计算相对方便，可以通过O(f(N)) &#x3D; R(N) &#x3D; Ω(f(N))来证明Θ(f(N)) &#x3D; R(N)</li></ul><p><img src="/2022/09/13/DataStructure/image-20220911180301223.png" alt="image-20220911180301223"></p><h2 id="Amortized-Analysis"><a href="#Amortized-Analysis" class="headerlink" title="Amortized Analysis"></a>Amortized Analysis</h2><p>如果一个算法在不同的情况下有着不同的复杂度，那么我们可以通过计算平均的复杂度来准确衡量一个算法的好坏</p><blockquote><p>如当一个数组空间不够大时，我们创建另一个两倍大小的数组，再将内容全部复制进去</p><p>否则直接加入数组</p><p>在这种情况下复杂度分成了两种情况，如果直接观察第一种需要另外创建数组的情况需要Θ(N)，但这并不能准确分析这样的算法的好坏</p><p>**平均复杂度 **</p><p>c<em>i</em>表示第i个确切的运算量</p><p>a<em>i</em>表示不变的平均运算量</p><p>Φ<em>i</em>(potential)表示累计剩余，Φ<em>i</em>&#x3D;Φ<em>i</em>−1+a<em>i</em>−c<em>i</em></p><p><strong>通过确保Φ<em>i</em>总是大于零可以确定a是c的上限，即一个常数a是整个算法复杂度的上限，那么就可以确定这个算法的复杂度是常数</strong></p><p><img src="/2022/09/13/DataStructure/image-20220911182247325.png" alt="image-20220911182247325"></p><p>所以我们知道数组的那个另外建立再复制对整个过程来说其实是常数而非线性</p><p><img src="/2022/09/13/DataStructure/image-20220911182705042.png" alt="image-20220911182705042"></p></blockquote><h1 id="Sort"><a href="#Sort" class="headerlink" title="Sort"></a>Sort</h1><ol><li><p>Selection SortΘ(N^2^)</p></li><li><p>Merge Sort    Θ(N logN)</p><p>核心思想：</p><ol><li><p>merge</p><blockquote><p>将两个已经排序的list利用已经排序的特性合并成一个Θ(N)</p></blockquote></li><li><p>拆分合并</p><ul><li><p>将list拆分到size为1</p></li><li><p>将拆分出来的list两两进行merge合并</p></li><li><p>重复两两合并的操作直到合并为一个list</p></li></ul></li></ol></li></ol><h1 id="Disjoint-Set"><a href="#Disjoint-Set" class="headerlink" title="Disjoint Set"></a>Disjoint Set</h1><ol><li><p>定义</p><p>不包含重复元素的set</p></li><li><p>内部实现</p><blockquote><p>不同的算法实现会影响整个disjoint set的运行效率和使用难度，也会影响我们写的难度</p></blockquote><ol><li><p>list of sets</p></li><li><p>quick sort</p></li><li><p>quick union</p></li><li><p>weighted quick union</p><p>将set用tree表示</p><p>将元素作为下标，有一个对应的数组表示该元素的parent</p><p>如果一个元素是root，那么它的parent是整棵树weight的负数</p><p>当连接两个set时，将weight少的set的root接到另一个的root，相同则任意</p><p>那么就可以实现在find root时复杂度为O(logN)</p><blockquote><p>解释为什么是O(logN)</p><img src="/2022/09/13/DataStructure/image-20220913112249135.png" alt="image-20220913112249135" style="zoom:50%;"><p>一个set最坏的情况是上图所示</p><p>如果要将这个set加入到另一个set，那么另一个set的size &gt;&#x3D; 这个set的size</p><p>那么最终的高度是+1的，而weight(N)至少是*2的，也就是O(logN)</p></blockquote><p><img src="/2022/09/13/DataStructure/image-20220913112704516.png" alt="image-20220913112704516"></p></li></ol></li></ol><h1 id="Tree"><a href="#Tree" class="headerlink" title="Tree"></a>Tree</h1><h2 id="Binary-Search-Tree-BST"><a href="#Binary-Search-Tree-BST" class="headerlink" title="Binary Search Tree(BST)"></a>Binary Search Tree(BST)</h2><p>一个节点的值小于所有的右节点，大于左节点</p><blockquote><p>如果在random情况下，BST可以实现Θ(log N)，但如果我们输入如1,2,3,4,5,6,7这样的序列，在寻找时是Θ(N)</p></blockquote><p>解决方法</p><ol><li>Rotation</li></ol><p><img src="/2022/09/13/DataStructure/image-20220915201101395.png" alt="image-20220915201101395"></p><ol start="2"><li><p>红黑树</p><p>将BST的易实现与B-Tree思想的巧妙结合</p><p><img src="/2022/09/13/DataStructure/image-20220915215234645.png" alt="image-20220915215234645"></p><p><img src="/2022/09/13/DataStructure/image-20220915204949417.png" alt="image-20220915204949417"></p></li></ol><h2 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h2><img src="/2022/09/13/DataStructure/image-20220915203251330.png" alt="image-20220915203251330" style="zoom:50%;"><h1 id="Hash-Table"><a href="#Hash-Table" class="headerlink" title="Hash Table"></a>Hash Table</h1><p><img src="/2022/09/13/DataStructure/image-20220916111306923.png" alt="image-20220916111306923"></p><p>hashCode()</p><p>生成hash code的函数，好的hash code函数：</p><ul><li>一个对象的hash code应该是固定的(所以在hashCode函数内加入当前时间是无效的hash code生成函数)</li><li>任意两个equals的对象的hash code应该是相等的</li><li>运行效率要高</li><li>生成的hash code覆盖性要好</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>my first blog</title>
      <link href="/2022/08/19/my-first-blog/"/>
      <url>/2022/08/19/my-first-blog/</url>
      
        <content type="html"><![CDATA[<h2 id="test"><a href="#test" class="headerlink" title="test"></a>test</h2><h2 id="test-1"><a href="#test-1" class="headerlink" title="test"></a>test</h2><h2 id="test-2"><a href="#test-2" class="headerlink" title="test"></a>test</h2><h2 id="test-3"><a href="#test-3" class="headerlink" title="test"></a>test</h2><h2 id="test-4"><a href="#test-4" class="headerlink" title="test"></a>test</h2><h2 id="test-5"><a href="#test-5" class="headerlink" title="test"></a>test</h2><h2 id="test-6"><a href="#test-6" class="headerlink" title="test"></a>test</h2><h2 id="test-7"><a href="#test-7" class="headerlink" title="test"></a>test</h2><h2 id="test-8"><a href="#test-8" class="headerlink" title="test"></a>test</h2><h2 id="test-9"><a href="#test-9" class="headerlink" title="test"></a>test</h2><h2 id="test-10"><a href="#test-10" class="headerlink" title="test"></a>test</h2><h2 id="test-11"><a href="#test-11" class="headerlink" title="test"></a>test</h2><h2 id="test-12"><a href="#test-12" class="headerlink" title="test"></a>test</h2><h2 id="test-13"><a href="#test-13" class="headerlink" title="test"></a>test</h2><h2 id="test-14"><a href="#test-14" class="headerlink" title="test"></a>test</h2><h2 id="test-15"><a href="#test-15" class="headerlink" title="test"></a>test</h2><h2 id="test-16"><a href="#test-16" class="headerlink" title="test"></a>test</h2><h2 id="test-17"><a href="#test-17" class="headerlink" title="test"></a>test</h2><h2 id="test-18"><a href="#test-18" class="headerlink" title="test"></a>test</h2><h2 id="test-19"><a href="#test-19" class="headerlink" title="test"></a>test</h2><h2 id="test-20"><a href="#test-20" class="headerlink" title="test"></a>test</h2><h2 id="test-21"><a href="#test-21" class="headerlink" title="test"></a>test</h2><h2 id="test-22"><a href="#test-22" class="headerlink" title="test"></a>test</h2><h2 id="test-23"><a href="#test-23" class="headerlink" title="test"></a>test</h2><h2 id="test-24"><a href="#test-24" class="headerlink" title="test"></a>test</h2><h2 id="test-25"><a href="#test-25" class="headerlink" title="test"></a>test</h2><h2 id="test-26"><a href="#test-26" class="headerlink" title="test"></a>test</h2><h2 id="test-27"><a href="#test-27" class="headerlink" title="test"></a>test</h2><h2 id="test-28"><a href="#test-28" class="headerlink" title="test"></a>test</h2><h2 id="test-29"><a href="#test-29" class="headerlink" title="test"></a>test</h2><h2 id="test-30"><a href="#test-30" class="headerlink" title="test"></a>test</h2><h2 id="test-31"><a href="#test-31" class="headerlink" title="test"></a>test</h2><h2 id="test-32"><a href="#test-32" class="headerlink" title="test"></a>test</h2><h2 id="test-33"><a href="#test-33" class="headerlink" title="test"></a>test</h2><h2 id="test-34"><a href="#test-34" class="headerlink" title="test"></a>test</h2><h2 id="test-35"><a href="#test-35" class="headerlink" title="test"></a>test</h2><p>sfdfdf<br>dfsd<br>sdfdsf<br>dfffffffffffffffffffffffffffffffffff<br>ddddddddddddddddddddddddddddddddddddddddd<br>dd</p><p>sfdfdf<br>dfsd<br>sdfdsf<br>dfffffffffffffffffffffffffffffffffff<br>ddddddddddddddddddddddddddddddddddddddddd<br>dd<br>sfdfdf<br>dfsd<br>sdfdsf<br>dfffffffffffffffffffffffffffffffffff<br>ddddddddddddddddddddddddddddddddddddddddd<br>dd<br>sfdfdf<br>dfsd<br>sdfdsf<br>dfffffffffffffffffffffffffffffffffff<br>ddddddddddddddddddddddddddddddddddddddddd<br>dd<br>sfdfdf<br>dfsd<br>sdfdsf<br>dfffffffffffffffffffffffffffffffffff<br>ddddddddddddddddddddddddddddddddddddddddd<br>dd<br>sfdfdf<br>dfsd<br>sdfdsf<br>dfffffffffffffffffffffffffffffffffff<br>ddddddddddddddddddddddddddddddddddddddddd<br>dd<br>sfdfdf<br>dfsd<br>sdfdsf<br>dfffffffffffffffffffffffffffffffffff<br>ddddddddddddddddddddddddddddddddddddddddd<br>dd<br>sfdfdf<br>dfsd<br>sdfdsf<br>dfffffffffffffffffffffffffffffffffff<br>ddddddddddddddddddddddddddddddddddddddddd<br>dd<br>sfdfdf<br>sdfdsf<br>dfffffffffffffffffffffffffffffffffff<br>ddddddddddddddddddddddddddddddddddddddddd<br>dd</p><p>sfdfdf<br>dfsd<br>sdfdsf<br>dfffffffffffffffffffffffffffffffffff<br>ddddddddddddddddddddddddddddddddddddddddd<br>dd<br>sfdfdf<br>dfsd<br>sdfdsf<br>dfffffffffffffffffffffffffffffffffff<br>ddddddddddddddddddddddddddddddddddddddddd<br>dd<br>sfdfdf<br>dfsd<br>sdfdsf<br>dfffffffffffffffffffffffffffffffffff<br>ddddddddddddddddddddddddddddddddddddddddd<br>dd<br>sfdfdf<br>dfsd<br>sdfdsf<br>dfffffffffffffffffffffffffffffffffff<br>ddddddddddddddddddddddddddddddddddddddddd<br>dd<br>sfdfdf<br>dfsd<br>sdfdsf<br>dfffffffffffffffffffffffffffffffffff<br>ddddddddddddddddddddddddddddddddddddddddd<br>dd<br>sfdfdf<br>dfsd<br>sdfdsf<br>dfffffffffffffffffffffffffffffffffff<br>ddddddddddddddddddddddddddddddddddddddddd<br>dd<br>sfdfdf<br>dfsd<br>sdfdsf<br>dfffffffffffffffffffffffffffffffffff<br>ddddddddddddddddddddddddddddddddddddddddd<br>dd<br>sfdfdfBy zeee<br>框架 Hexo|主题 Butterfly<br>sdfdsf<br>sfdfdf<br>dfsd<br>sdfdsf<br>dfffffffffffffffffffffffffffffffffff<br>ddddddddddddddddddddddddddddddddddddddddd<br>dd<br>sfdfdf<br>dfsd<br>sdfdsf<br>dfffffffffffffffffffffffffffffffffff<br>ddddddddddddddddddddddddddddddddddddddddd<br>dd<br>sfdfdf<br>dfsd<br>dfsd<br>sdfdsf<br>dfffffffffffffffffffffffffffffffffff<br>ddddddddddddddddddddddddddddddddddddddddd<br>dd<br>sfdfdf<br>dfsd<br>sdfdsf<br>dfffffffffffffffffffffffffffffffffff<br>ddddddddddddddddddddddddddddddddddddddddd<br>dd<br>sfdfdf<br>dfsd<br>sdfdsf<br>dfffffffffffffffffffffffffffffffffff<br>ddddddddddddddddddddddddddddddddddddddddd<br>dd<br>sfdfdf<br>dfsd<br>sdfdsf<br>dfffffffffffffffffffffffffffffffffff<br>ddddddddddddddddddddddddddddddddddddddddd<br>dd<br>sfdfdf<br>dfsd<br>sdfdsf<br>dfffffffffffffffffffffffffffffffffff<br>ddddddddddddddddddddddddddddddddddddddddd<br>dd<br>sfdfdf<br>dfsd<br>sdfdsf<br>dfffffffffffffffffffffffffffffffffff<br>ddddddddddddddddddddddddddddddddddddddddd<br>dd<br>sfdfdf<br>dfsd<br>sdfdsf<br>dfffffffffffffffffffffffffffffffffff<br>ddddddddddddddddddddddddddddddddddddddddd<br>dd<br>sfdfdf<br>dfsd<br>sdfdsf<br>dfffffffffffffffffffffffffffffffffff<br>ddddddddddddddddddddddddddddddddddddddddd<br>dd<br>sfdfdf<br>dfsd<br>sdfdsf<br>dfffffffffffffffffffffffffffffffffff<br>ddddddddddddddddddddddddddddddddddddddddd<br>dd<br>sfdfdf<br>dfsd<br>sdfdsf<br>dfffffffffffffffffffffffffffffffffff<br>ddddddddddddddddddddddddddddddddddddddddd<br>dd<br>sfdfdf<br>dfsd<br>sdfdsf<br>dfffffffffffffffffffffffffffffffffff<br>ddddddddddddddddddddddddddddddddddddddddd<br>dd</p><p>&#x3D;&#x3D;sdfsd&#x3D;&#x3D;</p>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo test </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
